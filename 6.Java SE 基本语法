-class 类
 类是一组蓝图，设计图稿；类名每个单词首字母大写，后面可以有字母；类名与文件名一致
-Object 
 对象拿着蓝图制造出一组实例
-method 方法
 主方法是入口；相当于C语言的函数function
-变量 variable
 语法规则：变量类型  标识符identifier（变量名称）
 1.字面量(Literal)     int a=10
 2.另一个变量          int b=a;
 3.方法的返回值        int  m=max(a,b)
 如果两边的类型一样，可以赋值
 左边的类型比较大
 long a=10    隐式类型转换
 或者右边的类型比较大
  int a=10L(会报错）
  int a=(int)10L；强制类型转换/显示类型转换
 -标识符identifier规定
  1.必须以字母开头（不能以数字或者特殊字符开头）
  2.可以跟字母、数字、下划线_、$
  3.长度可以无限长
  4.不能用关键字起名字
  规范
  1.永远不要用中文作为标识符
  2.不要出现$
  3.不要出现下划线_,除了定义不可变的变量
  4.变量（名词） 首个单词全小写，后边首字母大写，其他小写
  5.方法（动词） 首个单词全小写，后边首字母大写，其他小写
  6.类名（名词)  每个单词首字母大写，其他小写
  阿⾥编码规范：
  1. 代码中的命名均不能以下划线或美元符号开始，也不能以下划线和美元符号结束。
  2. 代码命名严禁使⽤拼⾳与英⽂混合的⽅式，更不允许直接使⽤中⽂。
  3. 类名使⽤UpperCamelCase⻛格，⽅法名、参数名、成员变量、局部变量统⼀使⽤lowerCamelCase⻛格。
  4. 常量命名全部⼤写，单词间⽤下划线隔开。
 -变量类型
 一.基本类型
    1.数值类型
      整型 
      byte  1字节   byte a=-128; byte b=127;System.out.println(a-1);System.out.println(b+1); 输出-129；128 实际上强转为int类型
      short 2字节
      int   4字节  10  int maxValue = Integer.MAX_VALUE;int minValue = Integer.MIN_VALUE;
                      System.out.println(maxValue+1);System.out.println(minValue-1);最小值-1 为最大值；最大值+1 为最小值
      long  8字节  10L
      四种进制表示 二进制 0b/0B   八进制  0      十进制      十六进制 0Xff
      浮点类型 float 4字节  1.0F  double 8字节  1.0
      字符类型 char  2字节(Unicode码点） char c='\u4e2d'   1.任何情况都是UTF-8 
    2.布尔类型 boolean true/false 引用字面量null
 二.引用类型
    1.数组引用
    2.类引用
    3.接口引用
-运算符
 1.赋值运算符  =
 a=10 ;把右边的值赋给左边的变量
 2.算术运算符 
 + - * / %
 3.+10 -10
 4.a=5; int b =a++; b=5;a=6; int b =++a; b=6;a=6;
   a--;--a    
 5.!布尔类型
 6.比较运算符 
 ==相等 ！=不等 > < >= <=
 7.三目运算符
 布尔类型？值1：值2
 8.逻辑 与 或
  条件1 && 条件2 条件1，2 均为布尔类型
  条件1 || 条件2 
 9.instanceof 判断变量是否是指定类型
 10.~（按位取反） &（按位与） ~（按位异或） | （位或） <<(左移） >> (右移） >>>(不带符号向右移动二进制数）
-什么是 Unicode
 ASCII 7bit A-Z
 Unicode
 GB      国标 一个中文占2个字节
 UTF-8   中文占3个字节
 -方法定义
  public static 返回值类型 方法名称（形参列表）{
  }
 -方法调用
  方法名称（实参列表）
 -赋值的内存模型理解
  类型：框的大小
  变量名：主要用于在编译期间；用处是通过名称找到框；
  赋值操作：把值按照布局放到框中
-System.out.printf("%n");%n是因为Java是无关环境的，Windows上是\r\n;而Linux/unix是\n;
-短路与、或
--当使⽤"&"时，明确的表示多个条件都判断了，如果在多个表达式中有条件返回了false，剩余的条件也要判断；⽽如果使⽤"&&"(短路与)，只要有条件返回false，
  剩余条件不再判断，返回false。
--当使⽤"|"时，明确的表示多个条件都判断了，如果在多个表达式中有条件返回了true，剩余的条件也要判断；⽽如果使⽤"||"(短路⾮)，只要有条件返回true，
  剩余条件不再判断，返回true。
-在Java中，程序⼀共有三种结构：顺序结构、条件结构、循环结构、子路径结构
-条件结构
--if(布尔表达式){
 //条件满⾜时执⾏代码
 }else{
 //条件不满⾜时执⾏代码
 }
--switch(数字|枚举|字符|字符串){
case 内容1 : {
内容满⾜时执⾏语句; [break;]
}
case 内容2 : {
内容满⾜时执⾏语句; [break;]
}
- 循环结构
--while(循环结束条件判断){
  循环语句;
  修改修改循环结束判断; }
--do{
  循环语句;
  修改循环结束判断; }while(循环结束条件判断);
--for(循环初始化;循环结束判断;修改循环结束条件){
  循环体; }
  --foreach
  int[] a={1,2,3,4,5};
  for(int i=0;i<a.length;i++){
   System.out.println(a[i]);
   }
  foreach(int v:a){//v是变量，a是容器
  System.out.println(v);
   }
 -break & continue
   break label:
   continue label:
   continue:执⾏到此语句时会跳过当前循环的剩余部分，返回循环判断;
   break:退出整个循环.
-方法
--⽅法的定义
 限定符:Modifers（public，static） 返回值类型（void) 方法名称（main） （形参列表 String []args) 异常列表
 形参 ：paraments
 实参：arguments
--⽅法的调用
 方法名称（实参列表)
--方法调用的过程（内存模型）
 入口——主方法 （局部变量/形参）调用过程是值拷贝的过程 方法调用栈 形参的改变不会改变实参
-方法重载(overload）：⽅法名称相同、参数列表不同；
 ⽅法的签名：指的是⽅法名与参数，返回类型不是签名的⼀部分。
-数组
 int a={1,2,3...}
 int []a=new int [5];//如果数组中的元素没有初始化，元素的值计算对应类型的默认值 int 0 double 0.0 只定义一个数组类型的引用变量
 int []a=new int[5]{1,2,3...}
--引用类型
  java的内存模型   
 - 引用的方法调用也是值传递 形参的改变不会影响实参
   int a[]=null ;a 引用没有指向任何数组
 - 引用类型是个线索 用来找到堆中的真正数据
 - java中的垃圾回收（garbage collection）
 - -谁是垃圾？
 - 没有使用价值的；没有引用指向的对象（数组）在适当的时候回收它
 --数组操作
   获取数组的长度 a.length /字符 String s s.length()
                NullPointerException
   遍历数组 foreach(int element:a){
           element;
           }
 --理解引用
   1.引用是用来找到实际对象的线索 
          指向
   引用------------对象
   2.java内存中有3个区域
     栈区 堆区 方法区
   3.变量四种
   形参            栈
   局部变量         栈
   属性            堆   a[0] 所有对象
   静态属性        方法区（随着方法存在在方法区）
   4.一些操作的理解
    int[]a={1,2,3,4,5}
    int[]b=a;//b也指向a指向的数组对象
    1)b={10,11,12}//b重新指向新的数组对象，不会影响a和a指向的对象
    2)b[0]=100;//改变的是b指向的数组对象的内容，会影响a
   5.方法调用
     入口——主方法 （局部变量/形参）调用过程是值拷贝的过程 方法调用栈 形参的改变不会改变实参
   --JDK支持的一些数组操作
     java.util.Arrays包
     System.arraycopy(源数组引用，源下标，目标数组引用，目标下标，长度）；
     Arrays.fill(int []a,int v);
     Arrays.copyOf(int []a,int newLengeth)
     Arrays.copyOfRange(int []a,int from,int to);
     
